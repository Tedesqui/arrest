<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corre√ß√£o de Provas AR + OCR + ChatGPT</title>

    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.1/dist/tesseract.min.js"></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            background: black;
            color: white;
            overflow: hidden;
            display: flex;
            flex-direction: column; /* Para posicionar os controles */
            align-items: center;
            justify-content: center;
        }
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            object-fit: cover;
            z-index: 0;
        }
        #output {
            position: fixed;
            bottom: 0;
            width: 100%;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            font-size: 16px;
            z-index: 2;
            max-height: 40vh;
            overflow-y: auto;
            box-sizing: border-box; /* Inclui padding na largura total */
        }
        #controls {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 3;
            display: flex;
            flex-direction: column; /* Bot√µes um abaixo do outro */
            gap: 8px; /* Espa√ßo entre os bot√µes */
        }
        button {
            font-size: 16px;
            padding: 8px 12px;
            background: #0d6efd;
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        button:hover {
            background: #0a58ca;
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            opacity: 0.7;
        }
    </style>
</head>
<body>

    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas" width="640" height="480" style="display:none;"></canvas>

    <div id="controls">
        <button id="zoomToggleBtn" disabled>Zoom</button>
        <button id="captureBtn">Corrigir</button>
    </div>

    <div id="output">üì∑ Aponte a c√¢mera para a resposta da prova e toque em "Corrigir"</div>

    <script>
        // --- 1. Seletores de Elementos HTML ---
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const output = document.getElementById("output");
        const zoomToggleBtn = document.getElementById('zoomToggleBtn');
        const captureBtn = document.getElementById('captureBtn');

        // --- 2. Vari√°veis de Controle da C√¢mera e Zoom ---
        let mediaTrack; // Armazena a trilha de v√≠deo da c√¢mera para controle
        let zoomCapabilities = {}; // Armazena as capacidades de zoom (min, max, step)
        let currentZoom = 1.0; // N√≠vel de zoom atual da c√¢mera
        let zoomDirection = 1; // 1: aumentar zoom, -1: redefinir/diminuir zoom
        const ZOOM_INCREMENT_FACTOR = 0.5; // Fator de incremento/decremento se 'step' n√£o for definido

        // --- 3. Fun√ß√µes Ass√≠ncronas ---

        /**
         * Inicia o stream de v√≠deo da c√¢mera traseira e configura as capacidades de zoom.
         */
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: { exact: "environment" }, // Prefer√™ncia pela c√¢mera traseira
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                video.srcObject = stream;
                mediaTrack = stream.getVideoTracks()[0]; // Obt√©m a trilha de v√≠deo

                // Espera o v√≠deo carregar metadados para ter as dimens√µes corretas
                await new Promise(resolve => video.onloadedmetadata = resolve);

                // Configura o canvas com as dimens√µes reais do v√≠deo
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // Verifica e configura as capacidades de zoom
                if (mediaTrack && typeof mediaTrack.getCapabilities === 'function') {
                    zoomCapabilities = mediaTrack.getCapabilities();
                    if (zoomCapabilities.zoom) {
                        const { min, current } = zoomCapabilities.zoom;
                        currentZoom = current || min; // Define o zoom inicial como o atual ou o m√≠nimo
                        zoomToggleBtn.disabled = false; // Habilita o bot√£o de zoom
                        console.log('Capacidades de Zoom:', zoomCapabilities.zoom);
                    } else {
                        output.innerText = "‚ö†Ô∏è Zoom n√£o suportado neste dispositivo. Iniciando OCR...";
                        zoomToggleBtn.disabled = true; // Desabilita o bot√£o se n√£o houver suporte
                    }
                } else {
                    output.innerText = "‚ö†Ô∏è Navegador n√£o suporta controle de zoom program√°tico. Iniciando OCR...";
                    zoomToggleBtn.disabled = true; // Desabilita o bot√£o se a API n√£o estiver dispon√≠vel
                }
                updateOutputStatus("C√¢mera iniciada. Toque em 'Corrigir'.", currentZoom);

            } catch (err) {
                console.error("Erro ao acessar a c√¢mera:", err);
                output.innerText = `‚ùå Erro ao iniciar a c√¢mera: ${err.message}. Verifique as permiss√µes.`;
                zoomToggleBtn.disabled = true;
                captureBtn.disabled = true; // Desabilita o bot√£o de corre√ß√£o se a c√¢mera falhar
            }
        }

        /**
         * Aplica o n√≠vel de zoom na c√¢mera.
         * @param {number} targetZoom O valor de zoom desejado.
         */
        async function applyZoom(targetZoom) {
            if (!mediaTrack || !zoomCapabilities.zoom) {
                updateOutputStatus("Zoom n√£o suportado ou c√¢mera n√£o iniciada.", currentZoom);
                return;
            }

            const { min, max, step } = zoomCapabilities.zoom;
            // Garante que o zoom esteja dentro dos limites min/max
            let newZoom = Math.max(min, Math.min(max, targetZoom));

            // Arredonda para o passo mais pr√≥ximo, se 'step' for definido
            if (step && step > 0) {
                newZoom = Math.round(newZoom / step) * step;
            }

            try {
                await mediaTrack.applyConstraints({
                    advanced: [{ zoom: newZoom }]
                });
                currentZoom = newZoom; // Atualiza o zoom atual
                updateOutputStatus(`Zoom: ${currentZoom.toFixed(2)}x`, currentZoom);
                
                // Atualiza o texto do bot√£o de zoom para indicar a pr√≥xima a√ß√£o
                if (currentZoom >= max) {
                    zoomToggleBtn.textContent = "Redefinir Zoom";
                } else if (currentZoom <= min) {
                    zoomToggleBtn.textContent = "Zoom +";
                } else {
                    // Podemos manter "Zoom" ou algo como "Zoom +/-" se estiver no meio
                    zoomToggleBtn.textContent = "Zoom +/-"; 
                }

            } catch (err) {
                console.error('Erro ao aplicar zoom:', err);
                output.innerText = `‚ùå Erro ao aplicar zoom: ${err.message}`;
            }
        }

        /**
         * Alterna o n√≠vel de zoom da c√¢mera (aumenta ou redefinir para o m√≠nimo).
         */
        async function toggleZoom() {
            const { min, max, step } = zoomCapabilities.zoom;
            let nextZoom;
            const increment = step || (max - min) * ZOOM_INCREMENT_FACTOR; // Usa step ou um fator

            if (zoomDirection === 1) { // Aumentar o zoom
                nextZoom = currentZoom + increment;
                if (nextZoom >= max) {
                    nextZoom = max; // Garante que n√£o exceda o m√°ximo
                    zoomDirection = -1; // Altera para diminuir/redefinir no pr√≥ximo clique
                }
            } else { // Diminuir ou redefinir o zoom
                nextZoom = min; // Volta para o zoom m√≠nimo
                zoomDirection = 1; // Altera para aumentar no pr√≥ximo clique
            }
            
            await applyZoom(nextZoom);
        }

        /**
         * Captura um frame do v√≠deo, realiza OCR e envia o texto para o ChatGPT.
         */
        async function captureAndAnalyze() {
            if (!video.srcObject) {
                output.innerText = "‚ùå C√¢mera n√£o iniciada. Tente recarregar a p√°gina.";
                return;
            }

            ctx.drawImage(video, 0, 0, canvas.width, canvas.height); // Desenha o frame no canvas

            updateOutputStatus("üß† Lendo resposta com OCR...", currentZoom);
            captureBtn.disabled = true; // Desabilita o bot√£o enquanto processa

            try {
                // Realiza OCR no canvas
                const { data: { text } } = await Tesseract.recognize(canvas, 'por', {
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            output.innerText = `üß† OCR: ${Math.round(m.progress * 100)}% conclu√≠do...`;
                        } else {
                            console.log(m);
                        }
                    }
                });

                if (!text.trim()) {
                    output.innerText = "‚ö†Ô∏è Nenhum texto detectado pelo OCR. Tente novamente com mais luz ou foco.";
                    captureBtn.disabled = false;
                    return;
                }

                updateOutputStatus("üîé Texto detectado:\n" + text + "\n\nEnviando para o ChatGPT...", currentZoom);

                // Envia o texto para a API do OpenAI (ChatGPT)
                const response = await fetch("https://api.openai.com/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer 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" // !!! SUBSTITUA PELA SUA CHAVE REAL DA OPENAI !!!
                    },
                    body: JSON.stringify({
                        model: "gpt-4", // Ou "gpt-3.5-turbo" para mais velocidade/custo-benef√≠cio
                        messages: [
                            { role: "system", content: "Voc√™ √© um professor corrigindo provas curtas. Seja conciso e d√™ uma nota de 0 a 10 com justificativa clara e focada na corre√ß√£o da resposta. A resposta do aluno √© a que est√° no prompt." },
                            { role: "user", content: "Corrija e avalie esta resposta de prova do aluno:\n" + text }
                        ],
                        temperature: 0.7, // Criatividade da resposta
                        max_tokens: 200 // Limita o tamanho da resposta do ChatGPT
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API: ${response.status} - ${errorData.error.message || response.statusText}`);
                }

                const data = await response.json();
                const answer = data.choices[0].message.content;
                output.innerText = "‚úÖ Corre√ß√£o:\n" + answer;

            } catch (error) {
                console.error("Erro na corre√ß√£o:", error);
                output.innerText = `‚ùå Erro ao corrigir: ${error.message}. Verifique a chave da API e a conex√£o.`;
            } finally {
                captureBtn.disabled = false; // Reabilita o bot√£o "Corrigir"
            }
        }

        /**
         * Atualiza a √°rea de sa√≠da de status.
         * @param {string} message A mensagem a ser exibida.
         * @param {number} [zoomLevel] O n√≠vel de zoom atual para incluir na mensagem (opcional).
         */
        function updateOutputStatus(message, zoomLevel = null) {
            output.innerHTML = message; // Usar innerHTML para permitir algumas tags HTML se necess√°rio
            if (zoomLevel !== null && zoomCapabilities.zoom) {
                // Adiciona o status do zoom √† mensagem principal, mas evita duplicar se j√° estiver l√°
                if (!output.innerText.includes("Zoom:")) {
                    output.innerText += `\n(Zoom: ${zoomLevel.toFixed(2)}x)`;
                }
            }
        }

        // --- 4. Event Listeners ---
        zoomToggleBtn.addEventListener('click', toggleZoom);
        captureBtn.addEventListener('click', captureAndAnalyze);

        // --- 5. Inicializa√ß√£o da Aplica√ß√£o ---
        startCamera(); // Inicia a c√¢mera ao carregar a p√°gina
    </script>
</body>
</html>
